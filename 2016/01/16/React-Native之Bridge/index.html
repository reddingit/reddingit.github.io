<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Give it five minutes"><title>React-Native之Bridge | 5 minutes walk</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React-Native之Bridge</h1><a id="logo" href="/.">5 minutes walk</a><p class="description">Sometimes in life you feel the fight is over...</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React-Native之Bridge</h1><div class="post-meta">Jan 16, 2016<span> | </span><span class="category"><a href="/categories/React-Native/">React Native</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/01/16/React-Native之Bridge/" href="/2016/01/16/React-Native之Bridge/#comments" class="ds-thread-count"></a><div class="post-content"><p>原文：<a href="http://tadeuzagallo.com/blog/react-native-bridge/" target="_blank" rel="external">BRIDGING IN REACT NATIVE</a></p>
<p>本文假定读者了解React Native开发，并且想了解Native和JavaScript通信的内部机制。</p>
<a id="more"></a>
<h2 id="Main_Threads"><a href="#Main_Threads" class="headerlink" title="Main Threads"></a>Main Threads</h2><p>开始之前，我们先介绍一下React Native中的三种<strong><em>main thread</em></strong>：</p>
<ul>
<li><strong>shadow queue</strong>：页面元素布局在这进行</li>
<li><strong>main thread</strong>：UIKit 运行的所在的线程</li>
<li><strong>JavaScript thread</strong>：运行JS代码时所处的线程</li>
</ul>
<p>此外，每个Native module都有各自独立的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="external">GCD Queue</a>，你也可以指定Native module运行的GCD queue（后面会详细介绍）。</p>
<p>*”shadow queue”实际上是一个GCD Queue，而不是一个线程。</p>
<h2 id="Native_Modules"><a href="#Native_Modules" class="headerlink" title="Native Modules"></a>Native Modules</h2><p><em>如果还不知道怎么创建一个Native Module，建议你先去阅读一下相关的<a href="http://facebook.github.io/react-native/docs/native-modules-ios.html#content" target="_blank" rel="external">文档</a>。</em></p>
<p>下面我们定义一个示例的Native Module：<strong>Person</strong>，既可以接受JS端调用，也可以调用JS端代码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Logger</span></span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(greet:(<span class="built_in">NSString</span> *)name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Hi, %@!"</span>, name);</span><br><span class="line">  [_bridge<span class="variable">.eventDispatcher</span> sendAppEventWithName:<span class="string">@"greeted"</span></span><br><span class="line">                                           body:@&#123; <span class="string">@"name"</span>: name &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们先来看看<strong><code>RCT_EXPORT_MODULE</code></strong>,<strong><code>RCT_EXPORT_METHOD</code></strong>这两个宏，它们最终会生成什么代码，它们的角色是什么，在此基础上它们如何工作。</p>
<h2 id="RCT_EXPORT_MODULE_28_5Bjs_name_5D_29"><a href="#RCT_EXPORT_MODULE_28_5Bjs_name_5D_29" class="headerlink" title="RCT_EXPORT_MODULE([js_name])"></a><code>RCT_EXPORT_MODULE([js_name])</code></h2><p>从名字上看，它可以exports modules，那么在这export的作用究竟是什么呢？export的作用就是让bridge知道有一个module可以被JS调用了。</p>
<p>以下是它的宏定义：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> RCT_EXPORT_MODULE(js_name) \</span></span><br><span class="line">	<span class="function">RCT_EXTERN <span class="keyword">void</span> <span class="title">RCTRegisterModule</span>(<span class="params">Class</span>)</span>; \</span><br><span class="line">	+ (NSString \*)moduleName &#123; <span class="keyword">return</span> @<span class="preprocessor">#js_name; &#125; \</span></span><br><span class="line">	+ (<span class="keyword">void</span>)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure>
<p>主要做了以下这些事情：</p>
<ul>
<li>首先声明<strong>extern</strong>的函数<strong>RCTRegisterModule</strong>，也就意味着对于编译器，函数实现当前是不可见的，直到链接时才可用。然后</li>
<li>声明方法<strong>moduleName</strong>，它的返回值是<strong>js_name</strong>（宏的参数，可选）。如果你想在JS端使用和objc端不同的module名称，需要传非空的js_name。最后</li>
<li>声明方法<strong>load</strong>（当app被加载进内存的时候，会调用每个类的<strong>load</strong>方法），它会调用前面定义的<strong>RCTRegisterModule</strong>函数，告诉bridge我们定义了这个module。</li>
</ul>
<h2 id="RCT_EXPORT_METHOD_28method_29"><a href="#RCT_EXPORT_METHOD_28method_29" class="headerlink" title="RCT_EXPORT_METHOD(method)"></a><code>RCT_EXPORT_METHOD(method)</code></h2><p>这个宏更有趣，它本身并没有给你定义的mdule方法添加任何东西，除了你定义的方法，它额外生成了一个新方法。</p>
<p>这个新方法看起来就像下面这样：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="constant">NSArray</span> *)__rct_export__120</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="annotation">@[ @<span class="string">""</span>, @<span class="string">"log:(NSString *)message"</span> ]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这是什么黑魔法？是不是很不可思议</em>。</p>
<p>方法名由三部分组成：前缀（<strong><code>__rct_export__</code></strong>），可选的<strong>js_name</strong>（当前示例为空），原方法的声明的行号（通过<strong><code>__COUNTER__</code></strong>获取，当前示例是12）。</p>
<p>新方法的目的是返回一个由原方法<strong>js_name</strong>（当前示例为空）和原方法签名组成的数组。新方法的名的特殊组成方式是为了避免方法冲突*。</p>
<p><em>*如果使用了category，技术上来说两个方法名相同是有可能的。但很可能不会导致任何预期的行为，尽管Xcode会警告有一个意料外的行为</em>。</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>上述所有的设置都是为了让bidge知道所有的export的module和method，这些都发生在APP被加载进内存的时候。现在我们来看看runtime的时候发生了什么。</p>
<p>下面是bridge的初始化时的流程图：<br><img src="http://tadeuzagallo.com/blog/assets/img/initialisation.svg" alt="bridge initialisation dependency graph"></p>
<h2 id="u521D_u59CB_u5316Module"><a href="#u521D_u59CB_u5316Module" class="headerlink" title="初始化Module"></a>初始化Module</h2><p><strong>RCTRegisterModule</strong>的作用是把export的类（module）添加进module数组，这样稍后生成新bridge实例的时候，bridge可以找到这些module。在bridge生成的过程中，会遍历module数组，为每一个module创建实例引用，并把引用存储在bridge上，同时也会给每个module实例添加一个bridge的引用（为了在module中调用bridge），然后检查module有没有指定运行的<strong>queue</strong>，没有就给它创建一个新的queue，保证每个module运行在不同的queue之中。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *modulesByName; <span class="comment">// = ...</span></span><br><span class="line"><span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> RCTGetModuleClasses()) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">module</span> = [moduleClass <span class="keyword">new</span>];</span><br><span class="line">  <span class="keyword">if</span> ([<span class="keyword">module</span> respondsToSelector:<span class="annotation">@selector</span>(setBridge:)]) &#123;</span><br><span class="line">    <span class="keyword">module</span>.bridge = self;</span><br><span class="line">  &#125;</span><br><span class="line">  modulesByName[moduleName] = <span class="keyword">module</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6Emodule"><a href="#u914D_u7F6Emodule" class="headerlink" title="配置module"></a>配置module</h2><p>当所有的module实例创建完成之后，我们会在后台线程中继续遍历每一个module的所有方法，调用以<strong><code>__rct_export__</code></strong>开头的方法，获取到export的方法的方法签名的字符串标识。这样做的目的在于我们可以获得方法中每一个参数的类型，而在runtime时我们只能知道参数的类型是<strong>id</strong>。本例中通过这种方式我们可以知道参数的实际类型是<strong>NSString *</strong>。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned <span class="type">int</span> methodCount;</span><br><span class="line"><span class="type">Method</span> *methods = class_copyMethodList(moduleClass, &amp;methodCount);</span><br><span class="line"><span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">  <span class="type">Method</span> <span class="keyword">method</span> = methods[i];</span><br><span class="line">  <span class="type">SEL</span> selector = method_getName(<span class="keyword">method</span>);</span><br><span class="line">  <span class="keyword">if</span> ([<span class="type">NSStringFromSelector</span>(selector) hasPrefix:@<span class="string">"__rct_export__"</span>]) &#123;</span><br><span class="line">    <span class="type">IMP</span> imp = method_getImplementation(<span class="keyword">method</span>);</span><br><span class="line">    <span class="type">NSArray</span> *entries = ((<span class="type">NSArray</span> *(*)(id, <span class="type">SEL</span>))imp)(_moduleClass, selector);</span><br><span class="line">    //...</span><br><span class="line">    [moduleMethods addObject:/* <span class="type">Object</span> representing the <span class="keyword">method</span> */];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8BBE_u7F6EJS_u6267_u884C_u5668"><a href="#u8BBE_u7F6EJS_u6267_u884C_u5668" class="headerlink" title="设置JS执行器"></a>设置JS执行器</h2><p>JS执行器有一个<strong>-setUp</strong>方法，这个方法在后台线程执行，可以做一些代价较高的工作，比如说初始化JavaScriptCore等。由于只有活跃的JS执行器才会接收到<strong>setUp</strong>的调用，而不是所有可用的JS执行器，因此也避免了一些不必要的操作。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSGlobalContextRef ctx = JSGlobalContextCreate(NULL)<span class="comment">;</span></span><br><span class="line">_context = [[RCTJavaScriptContext alloc] initWithJSContext:ctx]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>##注入JSON配置文件</p>
<p>包含module信息的JSON配置文件格式如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  <span class="string">"remoteModuleConfig"</span>: <span class="collection">&#123;</span><br><span class="line">    <span class="string">"Logger"</span>: <span class="collection">&#123;</span><br><span class="line">      <span class="string">"constants"</span>: <span class="collection">&#123; /* If we had exported constants... */ &#125;</span>,</span><br><span class="line">      <span class="string">"moduleID"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"methods"</span>: <span class="collection">&#123;</span><br><span class="line">        <span class="string">"requestPermissions"</span>: <span class="collection">&#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"remote"</span>,</span><br><span class="line">          <span class="string">"methodID"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span></span><br><span class="line">      &#125;</span></span><br><span class="line">    &#125;</span></span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>JSON配置文件作为一个全局变量存储在JavaScript VM中，当JS端的bridge初始化的时候使用这些配置来创建module。</p>
<h2 id="u52A0_u8F7DJS_u4EE3_u7801"><a href="#u52A0_u8F7DJS_u4EE3_u7801" class="headerlink" title="加载JS代码"></a>加载JS代码</h2><p>这个过程很直观，就是从指定的来源加载源码。通常情况下，开发阶段从packager获取，线上运行时从硬盘上获取。</p>
<h2 id="u6267_u884CJS_u4EE3_u7801"><a href="#u6267_u884CJS_u4EE3_u7801" class="headerlink" title="执行JS代码"></a>执行JS代码</h2><p>初始化工作全部完成以后，我们就可以把app源码加载进JavaScript VM了，具体过程是复制源码，解释执行。初始执行的时候会注册所有的CommonJS module，然后请求入口文件。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSValueRef jsError = NULL<span class="comment">;</span></span><br><span class="line">JSStringRef execJSString = JSStringCreateWithCFString<span class="list">(<span class="list">(<span class="keyword">__bridge</span></span><br><span class="line">      CFStringRef)</span>script)</span><span class="comment">;</span></span><br><span class="line">JSStringRef jsURL = JSStringCreateWithCFString<span class="list">(<span class="list">(<span class="keyword">__bridge</span></span><br><span class="line">      CFStringRef)</span>sourceURL.absoluteString)</span><span class="comment">;</span></span><br><span class="line">JSValueRef result = JSEvaluateScript<span class="list">(<span class="keyword">strongSelf-&gt;_context</span>.ctx,</span><br><span class="line">    execJSString, NULL, jsURL, <span class="number">0</span>, <span class="keyword">&amp;jsError</span>)</span><span class="comment">;</span></span><br><span class="line">JSStringRelease<span class="list">(<span class="keyword">jsURL</span>)</span><span class="comment">;</span></span><br><span class="line">JSStringRelease<span class="list">(<span class="keyword">execJSString</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="JS_u7AEF_u8C03_u7528module"><a href="#JS_u7AEF_u8C03_u7528module" class="headerlink" title="JS端调用module"></a>JS端调用module</h2><p>module由上述的JSON配置文件生成后，在JS端可以通过<strong>react-native</strong>对象的<strong>NativeModules</strong>调用。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; NativeModules &#125; = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</span><br><span class="line"><span class="keyword">var</span> &#123; Person &#125; = NativeModules;</span><br><span class="line"></span><br><span class="line">Person.greet(<span class="string">'Tadeu'</span>);</span><br></pre></td></tr></table></figure>
<p>示例代码的运行原理是：JS端发起module方法的调用，进入一个队列，获取调用所需的信息：module名称、方法名称、方法参数，信息获取完成之后交还给JS端执行调用。</p>
<h2 id="u8C03_u7528_u5468_u671F"><a href="#u8C03_u7528_u5468_u671F" class="headerlink" title="调用周期"></a>调用周期</h2><p>使用示例代码调用module时的整个流程如下图所示：</p>
<p><img src="http://tadeuzagallo.com/blog/assets/img/graph.svg" alt="call cycle"></p>
<p>调用始于JS端的本地*JS代码调用，本地JS代码期间：由于调用了<strong>NativeModules</strong>上的方法，调用进入Native端的执行队列。JS端代码发起方法调用结束后，Native端遍历队列中的所有调用并执行对应方法，执行完成后，回JS端回调函数，把处理权转移到JS端，或者通过bridge调用JS端（使用Native端module的<strong>_bridge</strong>引用调用<strong>enqueueJSCall:args:</strong>），把处理权转移到JS端。</p>
<p>*上图只描述了JS执行中的某一个时刻。</p>
<p><strong>注意</strong>：如果你之前曾经关注过项目，可能知道还有一个native–&gt;JS的调用队列，每次vSYNC的时候队列都会被分发，但是为了提高启动速度，这个队列已经被移除了。</p>
<h2 id="u53C2_u6570_u7C7B_u578B"><a href="#u53C2_u6570_u7C7B_u578B" class="headerlink" title="参数类型"></a>参数类型</h2><p>对于从Native端—&gt;JS端的调用，参数类型更容易处理，所有的参数放进<strong>NSArray</strong>，然后被编码成JSON格式。但是对于从JS端—&gt;Native端的调用，为了校验数据类型（int、float、char…），我们需要原生的数据类型。但是对于任意的对象（和结构体），runtime无法通过<strong>NSMethidSignature</strong>提供足够的类型信息。如果你还记得的话，我们已经把参数类型信息作为字符串存下来了。</p>
<p>我们用正则表达式从方法前面里提取出类型信息，然后用<strong><u>RCTConvert</u></strong>功能类转换对象。RCTConvert为所有支持的默认类型提供了转换方法，可以把JSON格式的输入转换成期望的类型。</p>
<p>我们用<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_msgSend" target="_blank" rel="external">objc_msgSend</a></strong>进行RCTConvert方法的动态调用。如果参数类型是<strong>struct</strong>，由于<strong>arm64</strong>没有提供<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_msgSend_stret" target="_blank" rel="external">objc_msgSend_stret</a></strong>的实现，我们用<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/" target="_blank" rel="external">NSInvocation</a></strong>调用。</p>
<p>获取到所有的参数之后，通过<strong>NSInvocation</strong>调用目标的module和方法。</p>
<p>下面是一个栗子：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// If you had the following method in a given module, e.g. <span class="code">`MyModule`</span></span><br><span class="line">RCT<span class="emphasis">_EXPORT_</span>METHOD(methodWithArray:(NSArray *) size:(CGRect)size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// And called it from JS, like:</span><br><span class="line">require('NativeModules').MyModule.method(['a', 1], &#123;</span><br><span class="line">  x: 0,</span><br><span class="line">  y: 0,</span><br><span class="line">  width: 200,</span><br><span class="line">  height: 100</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// The JS queue sent to native would then look like the following:</span><br><span class="line">// <span class="strong">** Remember that it's a queue of calls, so all the fields are arrays **</span></span><br><span class="line">@[</span><br><span class="line">  @[ @0 ], // module IDs</span><br><span class="line">  @[ @1 ], // method IDs</span><br><span class="line">  @[       // arguments</span><br><span class="line"><span class="code">    @[</span></span><br><span class="line"><span class="code">      @[@"a", @1],</span></span><br><span class="line"><span class="code">      @&#123; @"x": @0, @"y": @0, @"width": @200, @"height": @100 &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// This would convert into the following calls (pseudo code)</span><br><span class="line">NSInvocation call</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">0</span>] = GetModuleForId(@0)</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">1</span>] = GetMethodForId(@1)</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">2</span>] = obj_msgSend(RCTConvert, NSArray, @[@"a", @1])</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">3</span>] = NSInvocation(RCTConvert, CGRect, @&#123; @"x": @0, ... &#125;)</span><br><span class="line">call()</span><br></pre></td></tr></table></figure>
<h2 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h2><p>根据前面提到的， 默认每个module都有各自的<strong><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="external">GCD queue</a></strong>。如果想为module指定运行的queue，需要实现<strong>-methodQueue</strong>方法或者synthesize <strong>methodQueue</strong>属性。继承自<strong><a href="https://github.com/facebook/react-native/blob/master/React/Views/RCTViewManager.m" target="_blank" rel="external">RCTViewManager</a></strong>的<strong>View Managers</strong>*是例外，这些View Managers默认使用<strong>Shadow Queue</strong>，还有一个<strong>RCTJSThread</strong>比较特别，它仅仅是一个占位符，实际上它是指一个<strong>线程</strong>而不是一个<strong>队列</strong>。</p>
<p><strong>*View Managers</strong>实际上也不是例外，它们的基类中显示指定了shadow queue作为目标队列。</p>
<p>目前的线程相关的约定如下：</p>
<ul>
<li><strong>-init</strong>和<strong>-setBridge</strong>的调用在主线程进行；</li>
<li>所有的export的方法调用在指定的队列执行；</li>
<li>如果实现了<strong><a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTInvalidating.h" target="_blank" rel="external">RCTInvalidating</a></strong>协议，<strong>invalidate</strong>的调用在指定的队列执行；</li>
<li><strong>-dealloc</strong>方法在哪个线程调用视情况而定。</li>
</ul>
<p>当Native端收到JS端的批量方法调用时，这些方法调用根据目标队列放入各自组中，并行分发调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// group `calls` by `queue` in `buckets`</span></span><br><span class="line"><span class="keyword">for</span> (id <span class="built_in">queue</span> in buckets) &#123;</span><br><span class="line">  <span class="keyword">dispatch_block_t</span> block = ^&#123;</span><br><span class="line">    NSOrderedSet *calls = [buckets objectForKey:<span class="built_in">queue</span>];</span><br><span class="line">    <span class="keyword">for</span> (NSNumber *indexObj in calls) &#123;</span><br><span class="line">      <span class="comment">// Actually call</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">queue</span> == RCTJSThread) &#123;</span><br><span class="line">    [_javaScriptExecutor executeBlockOnJavaScriptQueue:block];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">queue</span>) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, block);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>上面这些我们大概讲解了一下brigde的工作机制。希望能够对想创建复杂的module或者想要贡献核心代码的同学们提供一些帮助。</p>
<p>如果还有不清晰、不深入的地方，或者想知道一些其他的任何东西，不要犹豫，快来找我吧！</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://5minuteswalk.com/2016/01/16/React-Native之Bridge/" data-id="cisq5lv5h000ldgseppetkq9i" class="article-share-link">分享到</a><div class="tags"><a href="/tags/React-Native/">React Native</a><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2016/01/18/React-Native之复用原生UI组件/" class="pre">React-Native之复用原生UI组件</a></div><div data-thread-key="2016/01/16/React-Native之Bridge/" data-title="React-Native之Bridge" data-url="http://5minuteswalk.com/2016/01/16/React-Native之Bridge/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/01/16/React-Native之Bridge/" data-title="React-Native之Bridge" data-url="http://5minuteswalk.com/2016/01/16/React-Native之Bridge/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://5minuteswalk.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/React-Native/" style="font-size: 15px;">React Native</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/卓有成效的管理者读书笔记一/">卓有成效的管理者读书笔记一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/重新上路/">重新上路</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/26/什么是优秀的程序员/">什么是优秀的程序员</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/React-Native之自定义下拉刷新/">React-Native之自定义下拉刷新</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/18/React-Native之复用原生UI组件/">React-Native之复用原生UI组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/16/React-Native之Bridge/">React-Native之Bridge</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://amsoft.cn/" title="A梦源码网" target="_blank">A梦源码网</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">5 minutes walk.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'5minuteswalk'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>