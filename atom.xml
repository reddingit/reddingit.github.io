<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[5 minutes walk]]></title>
  <subtitle><![CDATA[For a lifetime]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://5minsred.com/"/>
  <updated>2016-03-20T14:15:53.000Z</updated>
  <id>http://5minsred.com/</id>
  
  <author>
    <name><![CDATA[Redding Yu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[React-Native之复用原生UI组件]]></title>
    <link href="http://5minsred.com/2016/01/18/React-Native%E4%B9%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%94%9FUI%E7%BB%84%E4%BB%B6/"/>
    <id>http://5minsred.com/2016/01/18/React-Native之复用原生UI组件/</id>
    <published>2016-01-18T14:38:00.000Z</published>
    <updated>2016-03-20T14:15:53.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://moduscreate.com/leverage-existing-ios-views-react-native-app/" target="_blank" rel="external">Leverage Existing iOS Views In Your React Native App</a></p>
<p><img src="http://moduscreate.com/wp-content/uploads/2015/10/StanRNscreenshot.png" alt=""></p>
<a id="more"></a>
<p>当React Native还在蹒跚学步的时候，自2008年3月开始的iOS原生应用开发已经走过了6个年头，正是君生我未生，我生君已老。然而老的好处就在于积累了许多的经验感悟，往往可以做到事半功倍。这么些年以来，iOS开发者向社区贡献了大量的开源组件，奋战在一线的APP开发公司也积累了恒河沙数的各种工具、类库。更重要的是苹果公司为原生应用开发提供了大量的基础组件。今天我们研究一下如何在React Native中使用iOS原生的UI View Controller。</p>
<h3 id="u753B_u4E2AAPP_u8349_u56FE_u5148"><a href="#u753B_u4E2AAPP_u8349_u56FE_u5148" class="headerlink" title="画个APP草图先"></a>画个APP草图先</h3><p>为了弄明白React Native中怎么调用iOS原生View Controller，我们先来确定一下本文中原生APP应该长个什么样。下图左侧，是将要显示在屏幕上的原生View Controller，它可以和右侧的React Native代码互相通信。</p>
<p><img src="http://moduscreate.com/wp-content/uploads/2015/10/image001.png" alt=""></p>
<p>我们需要创建一个React Native的模块（原生组件）来封装原生View Controller，以便于在React Native中使用它，以及二者之间的互相通信。如下图所示：</p>
<p><img src="http://moduscreate.com/wp-content/uploads/2015/10/image002.png" alt=""></p>
<p>在深入介绍之前，我们先来了解一下标准React Native iOS应用的组织结构。如下图所示：</p>
<p><img src="http://moduscreate.com/wp-content/uploads/2015/10/image003.png" alt=""></p>
<p>其中最重要的一个组件是UIViewController的实例。（AppDelegate中的rootViewController）</p>
<p>下一步要做的是把rootViewController作为AppDelegate的属性对外提供。这样其他的类就可以引用rootViewController，本文中就是指那些显示在屏幕上的UIViewController的实例。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIViewController</span> *rootViewController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                      moduleName:<span class="string">@"MCDJ"</span></span><br><span class="line">                                               initialProperties:<span class="literal">nil</span></span><br><span class="line">                                                   launchOptions:launchOptions];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [[<span class="built_in">UIViewController</span> alloc] init];</span><br><span class="line">  rootViewController<span class="variable">.view</span> = rootView;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = rootViewController;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set reference to class property</span></span><br><span class="line">  <span class="keyword">self</span><span class="variable">.rootViewController</span> = rootViewController;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
<h3 id="u539F_u751F_u7EC4_u4EF6_u6765_u4E86"><a href="#u539F_u751F_u7EC4_u4EF6_u6765_u4E86" class="headerlink" title="原生组件来了"></a>原生组件来了</h3><p>现在我们已经可以在外部引用rootViewController，是时候创建一个原生组件来包装我们想要在React Native中使用的view了。我们拿MPMediaPickerController作为栗子。MPMediaPickerController是用来显示iOS媒体库的，它是UIViewController的子类。MPMediaPickerController就是为了做栗子而生的，它是modal controller，同时也实现了MPMediaPickerControllerDelegate代理，正合我用。</p>
<p>下面是MediaController的样例。<br>注意：为了支持选择播放音频，需要引入AVAudioPlayer。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"RCTBridge.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"RCTEventDispatcher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@import <span class="built_in">AVFoundation</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MediaController</span> : <span class="title">NSObject</span>&lt;<span class="title">RCTBridgeModule</span>,<span class="title">MPMediaPickerControllerDelegate</span>, <span class="title">AVAudioPlayerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">AVAudioPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">MPMediaPickerController</span> *mediaPicker;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) showMediaPicker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>下面的代码是两个主要的功能一些实现代码：</p>
<p>1 显示和隐藏媒体库</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)showMediaPicker &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.mediaPicker</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mediaPicker</span> = [[<span class="built_in">MPMediaPickerController</span> alloc] initWithMediaTypes:<span class="built_in">MPMediaTypeAnyAudio</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mediaPicker</span> setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mediaPicker</span> setAllowsPickingMultipleItems:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mediaPicker</span> setShowsCloudItems:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mediaPicker</span><span class="variable">.prompt</span> = <span class="string">@"Select song"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  AppDelegate *delegate = (AppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">  [delegate<span class="variable">.rootViewController</span> presentViewController:<span class="keyword">self</span><span class="variable">.mediaPicker</span> animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> hideMediaPicker() &#123;</span><br><span class="line">  AppDelegate *delegate = (AppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">  [delegate<span class="variable">.rootViewController</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 MPMediaPickerController与React Native通信</p>
<p>下面的代码是原生组件通过RCTBridge发出SongPlaying事件，并带上文件名称。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) mediaPicker:(<span class="built_in">MPMediaPickerController</span> *)mediaPicker didPickMediaItems:(<span class="built_in">MPMediaItemCollection</span> *)mediaItemCollection &#123;</span><br><span class="line">  <span class="built_in">MPMediaItem</span> *mediaItem = mediaItemCollection<span class="variable">.items</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">NSURL</span> *assetURL = [mediaItem valueForProperty:<span class="built_in">MPMediaItemPropertyAssetURL</span>];</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.bridge</span><span class="variable">.eventDispatcher</span> sendAppEventWithName:<span class="string">@"SongPlaying"</span> body:[mediaItem valueForProperty:<span class="built_in">MPMediaItemPropertyTitle</span>]];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码是React Native端订阅事件，并根据事件更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</span><br><span class="line"><span class="keyword">var</span> MediaController = <span class="built_in">require</span>(<span class="string">'NativeModules'</span>).MediaController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  Text,</span><br><span class="line">  TouchableHighlight,</span><br><span class="line">  View,</span><br><span class="line">  NativeAppEventEmitter</span><br><span class="line">&#125; = React;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCDJ</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">this</span>.getInitialState();</span><br><span class="line">        <span class="keyword">this</span>.bindMethods();</span><br><span class="line">    &#125;</span><br><span class="line">    bindMethods() &#123;</span><br><span class="line">        <span class="keyword">if</span> (! <span class="keyword">this</span>.bindableMethods) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> methodName <span class="keyword">in</span> <span class="keyword">this</span>.bindableMethods) &#123;</span><br><span class="line">            <span class="keyword">this</span>[methodName] = <span class="keyword">this</span>.bindableMethods[methodName].bind(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInitialState() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            songPlaying : <span class="string">'None'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// Add Event Listener for SongPlaying event from MediaController</span></span><br><span class="line">        NativeAppEventEmitter.addListener(<span class="string">'SongPlaying'</span>, (songName) =&gt; <span class="keyword">this</span>.setState(&#123;songPlaying : songName&#125;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是MediaController的代码实现，仅供参考。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MediaController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MediaController</span></span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> bridge = _bridge;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)showMediaPicker &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.mediaPicker</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mediaPicker</span> = [[<span class="built_in">MPMediaPickerController</span> alloc] initWithMediaTypes:<span class="built_in">MPMediaTypeAnyAudio</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mediaPicker</span> setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mediaPicker</span> setAllowsPickingMultipleItems:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mediaPicker</span> setShowsCloudItems:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mediaPicker</span><span class="variable">.prompt</span> = <span class="string">@"Select song"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  AppDelegate *delegate = (AppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">  [delegate<span class="variable">.rootViewController</span> presentViewController:<span class="keyword">self</span><span class="variable">.mediaPicker</span> animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) mediaPicker:(<span class="built_in">MPMediaPickerController</span> *)mediaPicker didPickMediaItems:(<span class="built_in">MPMediaItemCollection</span> *)mediaItemCollection &#123;</span><br><span class="line">  <span class="built_in">MPMediaItem</span> *mediaItem = mediaItemCollection<span class="variable">.items</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">NSURL</span> *assetURL = [mediaItem valueForProperty:<span class="built_in">MPMediaItemPropertyAssetURL</span>];</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.bridge</span><span class="variable">.eventDispatcher</span> sendAppEventWithName:<span class="string">@"SongPlaying"</span> body:[mediaItem valueForProperty:<span class="built_in">MPMediaItemPropertyTitle</span>]];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">NSError</span> *error;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span><span class="variable">.player</span> = [[<span class="built_in">AVAudioPlayer</span> alloc] initWithContentsOfURL:assetURL error:&amp;error];</span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.player</span> setDelegate:<span class="keyword">self</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [error localizedDescription]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.player</span> play];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hideMediaPicker();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) mediaPickerDidCancel:(<span class="built_in">MPMediaPickerController</span> *)mediaPicker &#123;</span><br><span class="line">  hideMediaPicker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark RCT_EXPORT</span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(showSongs) &#123;</span><br><span class="line">  [<span class="keyword">self</span> showMediaPicker];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark private-methods</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> hideMediaPicker() &#123;</span><br><span class="line">  AppDelegate *delegate = (AppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">  [delegate<span class="variable">.rootViewController</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://moduscreate.com/leverage-existing-ios-views-react-native-app/">Leverage Existing iOS Views In Your React Native App</a></p>
<p><img src="http://moduscreate.com/wp-content/uploads/2015/10/StanRNscreenshot.png" alt=""></p>]]>
    
    </summary>
    
      <category term="React Native" scheme="http://5minsred.com/tags/React-Native/"/>
    
      <category term="iOS" scheme="http://5minsred.com/tags/iOS/"/>
    
      <category term="react-native" scheme="http://5minsred.com/categories/react-native/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React-Native之Bridge]]></title>
    <link href="http://5minsred.com/2016/01/16/React-Native%E4%B9%8BBridge/"/>
    <id>http://5minsred.com/2016/01/16/React-Native之Bridge/</id>
    <published>2016-01-15T16:02:00.000Z</published>
    <updated>2016-03-20T14:15:22.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://tadeuzagallo.com/blog/react-native-bridge/" target="_blank" rel="external">BRIDGING IN REACT NATIVE</a></p>
<p>本文假定读者了解React Native开发，并且想了解Native和JavaScript通信的内部机制。</p>
<a id="more"></a>
<h2 id="Main_Threads"><a href="#Main_Threads" class="headerlink" title="Main Threads"></a>Main Threads</h2><p>开始之前，我们先介绍一下React Native中的三种<strong><em>main thread</em></strong>：</p>
<ul>
<li><strong>shadow queue</strong>：页面元素布局在这进行</li>
<li><strong>main thread</strong>：UIKit 运行的所在的线程</li>
<li><strong>JavaScript thread</strong>：运行JS代码时所处的线程</li>
</ul>
<p>此外，每个Native module都有各自独立的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="external">GCD Queue</a>，你也可以指定Native module运行的GCD queue（后面会详细介绍）。</p>
<p>*”shadow queue”实际上是一个GCD Queue，而不是一个线程。</p>
<h2 id="Native_Modules"><a href="#Native_Modules" class="headerlink" title="Native Modules"></a>Native Modules</h2><p><em>如果还不知道怎么创建一个Native Module，建议你先去阅读一下相关的<a href="http://facebook.github.io/react-native/docs/native-modules-ios.html#content" target="_blank" rel="external">文档</a>。</em></p>
<p>下面我们定义一个示例的Native Module：<strong>Person</strong>，既可以接受JS端调用，也可以调用JS端代码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Logger</span></span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(greet:(<span class="built_in">NSString</span> *)name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Hi, %@!"</span>, name);</span><br><span class="line">  [_bridge<span class="variable">.eventDispatcher</span> sendAppEventWithName:<span class="string">@"greeted"</span></span><br><span class="line">                                           body:@&#123; <span class="string">@"name"</span>: name &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们先来看看<strong><code>RCT_EXPORT_MODULE</code></strong>,<strong><code>RCT_EXPORT_METHOD</code></strong>这两个宏，它们最终会生成什么代码，它们的角色是什么，在此基础上它们如何工作。</p>
<h2 id="RCT_EXPORT_MODULE_28_5Bjs_name_5D_29"><a href="#RCT_EXPORT_MODULE_28_5Bjs_name_5D_29" class="headerlink" title="RCT_EXPORT_MODULE([js_name])"></a><code>RCT_EXPORT_MODULE([js_name])</code></h2><p>从名字上看，它可以exports modules，那么在这export的作用究竟是什么呢？export的作用就是让bridge知道有一个module可以被JS调用了。</p>
<p>以下是它的宏定义：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> RCT_EXPORT_MODULE(js_name) \</span></span><br><span class="line">	<span class="function">RCT_EXTERN <span class="keyword">void</span> <span class="title">RCTRegisterModule</span>(<span class="params">Class</span>)</span>; \</span><br><span class="line">	+ (NSString \*)moduleName &#123; <span class="keyword">return</span> @<span class="preprocessor">#js_name; &#125; \</span></span><br><span class="line">	+ (<span class="keyword">void</span>)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure>
<p>主要做了以下这些事情：</p>
<ul>
<li>首先声明<strong>extern</strong>的函数<strong>RCTRegisterModule</strong>，也就意味着对于编译器，函数实现当前是不可见的，直到链接时才可用。然后</li>
<li>声明方法<strong>moduleName</strong>，它的返回值是<strong>js_name</strong>（宏的参数，可选）。如果你想在JS端使用和objc端不同的module名称，需要传非空的js_name。最后</li>
<li>声明方法<strong>load</strong>（当app被加载进内存的时候，会调用每个类的<strong>load</strong>方法），它会调用前面定义的<strong>RCTRegisterModule</strong>函数，告诉bridge我们定义了这个module。</li>
</ul>
<h2 id="RCT_EXPORT_METHOD_28method_29"><a href="#RCT_EXPORT_METHOD_28method_29" class="headerlink" title="RCT_EXPORT_METHOD(method)"></a><code>RCT_EXPORT_METHOD(method)</code></h2><p>这个宏更有趣，它本身并没有给你定义的mdule方法添加任何东西，除了你定义的方法，它额外生成了一个新方法。</p>
<p>这个新方法看起来就像下面这样：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="constant">NSArray</span> *)__rct_export__120</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="annotation">@[ @<span class="string">""</span>, @<span class="string">"log:(NSString *)message"</span> ]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这是什么黑魔法？是不是很不可思议</em>。</p>
<p>方法名由三部分组成：前缀（<strong><code>__rct_export__</code></strong>），可选的<strong>js_name</strong>（当前示例为空），原方法的声明的行号（通过<strong><code>__COUNTER__</code></strong>获取，当前示例是12）。</p>
<p>新方法的目的是返回一个由原方法<strong>js_name</strong>（当前示例为空）和原方法签名组成的数组。新方法的名的特殊组成方式是为了避免方法冲突*。</p>
<p><em>*如果使用了category，技术上来说两个方法名相同是有可能的。但很可能不会导致任何预期的行为，尽管Xcode会警告有一个意料外的行为</em>。</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>上述所有的设置都是为了让bidge知道所有的export的module和method，这些都发生在APP被加载进内存的时候。现在我们来看看runtime的时候发生了什么。</p>
<p>下面是bridge的初始化时的流程图：<br><img src="http://tadeuzagallo.com/blog/assets/img/initialisation.svg" alt="bridge initialisation dependency graph"></p>
<h2 id="u521D_u59CB_u5316Module"><a href="#u521D_u59CB_u5316Module" class="headerlink" title="初始化Module"></a>初始化Module</h2><p><strong>RCTRegisterModule</strong>的作用是把export的类（module）添加进module数组，这样稍后生成新bridge实例的时候，bridge可以找到这些module。在bridge生成的过程中，会遍历module数组，为每一个module创建实例引用，并把引用存储在bridge上，同时也会给每个module实例添加一个bridge的引用（为了在module中调用bridge），然后检查module有没有指定运行的<strong>queue</strong>，没有就给它创建一个新的queue，保证每个module运行在不同的queue之中。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *modulesByName; <span class="comment">// = ...</span></span><br><span class="line"><span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> RCTGetModuleClasses()) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">module</span> = [moduleClass <span class="keyword">new</span>];</span><br><span class="line">  <span class="keyword">if</span> ([<span class="keyword">module</span> respondsToSelector:<span class="annotation">@selector</span>(setBridge:)]) &#123;</span><br><span class="line">    <span class="keyword">module</span>.bridge = self;</span><br><span class="line">  &#125;</span><br><span class="line">  modulesByName[moduleName] = <span class="keyword">module</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6Emodule"><a href="#u914D_u7F6Emodule" class="headerlink" title="配置module"></a>配置module</h2><p>当所有的module实例创建完成之后，我们会在后台线程中继续遍历每一个module的所有方法，调用以<strong><code>__rct_export__</code></strong>开头的方法，获取到export的方法的方法签名的字符串标识。这样做的目的在于我们可以获得方法中每一个参数的类型，而在runtime时我们只能知道参数的类型是<strong>id</strong>。本例中通过这种方式我们可以知道参数的实际类型是<strong>NSString *</strong>。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned <span class="type">int</span> methodCount;</span><br><span class="line"><span class="type">Method</span> *methods = class_copyMethodList(moduleClass, &amp;methodCount);</span><br><span class="line"><span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">  <span class="type">Method</span> <span class="keyword">method</span> = methods[i];</span><br><span class="line">  <span class="type">SEL</span> selector = method_getName(<span class="keyword">method</span>);</span><br><span class="line">  <span class="keyword">if</span> ([<span class="type">NSStringFromSelector</span>(selector) hasPrefix:@<span class="string">"__rct_export__"</span>]) &#123;</span><br><span class="line">    <span class="type">IMP</span> imp = method_getImplementation(<span class="keyword">method</span>);</span><br><span class="line">    <span class="type">NSArray</span> *entries = ((<span class="type">NSArray</span> *(*)(id, <span class="type">SEL</span>))imp)(_moduleClass, selector);</span><br><span class="line">    //...</span><br><span class="line">    [moduleMethods addObject:/* <span class="type">Object</span> representing the <span class="keyword">method</span> */];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8BBE_u7F6EJS_u6267_u884C_u5668"><a href="#u8BBE_u7F6EJS_u6267_u884C_u5668" class="headerlink" title="设置JS执行器"></a>设置JS执行器</h2><p>JS执行器有一个<strong>-setUp</strong>方法，这个方法在后台线程执行，可以做一些代价较高的工作，比如说初始化JavaScriptCore等。由于只有活跃的JS执行器才会接收到<strong>setUp</strong>的调用，而不是所有可用的JS执行器，因此也避免了一些不必要的操作。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSGlobalContextRef ctx = JSGlobalContextCreate(NULL)<span class="comment">;</span></span><br><span class="line">_context = [[RCTJavaScriptContext alloc] initWithJSContext:ctx]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>##注入JSON配置文件</p>
<p>包含module信息的JSON配置文件格式如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  <span class="string">"remoteModuleConfig"</span>: <span class="collection">&#123;</span><br><span class="line">    <span class="string">"Logger"</span>: <span class="collection">&#123;</span><br><span class="line">      <span class="string">"constants"</span>: <span class="collection">&#123; /* If we had exported constants... */ &#125;</span>,</span><br><span class="line">      <span class="string">"moduleID"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"methods"</span>: <span class="collection">&#123;</span><br><span class="line">        <span class="string">"requestPermissions"</span>: <span class="collection">&#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"remote"</span>,</span><br><span class="line">          <span class="string">"methodID"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span></span><br><span class="line">      &#125;</span></span><br><span class="line">    &#125;</span></span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>JSON配置文件作为一个全局变量存储在JavaScript VM中，当JS端的bridge初始化的时候使用这些配置来创建module。</p>
<h2 id="u52A0_u8F7DJS_u4EE3_u7801"><a href="#u52A0_u8F7DJS_u4EE3_u7801" class="headerlink" title="加载JS代码"></a>加载JS代码</h2><p>这个过程很直观，就是从指定的来源加载源码。通常情况下，开发阶段从packager获取，线上运行时从硬盘上获取。</p>
<h2 id="u6267_u884CJS_u4EE3_u7801"><a href="#u6267_u884CJS_u4EE3_u7801" class="headerlink" title="执行JS代码"></a>执行JS代码</h2><p>初始化工作全部完成以后，我们就可以把app源码加载进JavaScript VM了，具体过程是复制源码，解释执行。初始执行的时候会注册所有的CommonJS module，然后请求入口文件。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSValueRef jsError = NULL<span class="comment">;</span></span><br><span class="line">JSStringRef execJSString = JSStringCreateWithCFString<span class="list">(<span class="list">(<span class="keyword">__bridge</span></span><br><span class="line">      CFStringRef)</span>script)</span><span class="comment">;</span></span><br><span class="line">JSStringRef jsURL = JSStringCreateWithCFString<span class="list">(<span class="list">(<span class="keyword">__bridge</span></span><br><span class="line">      CFStringRef)</span>sourceURL.absoluteString)</span><span class="comment">;</span></span><br><span class="line">JSValueRef result = JSEvaluateScript<span class="list">(<span class="keyword">strongSelf-&gt;_context</span>.ctx,</span><br><span class="line">    execJSString, NULL, jsURL, <span class="number">0</span>, <span class="keyword">&amp;jsError</span>)</span><span class="comment">;</span></span><br><span class="line">JSStringRelease<span class="list">(<span class="keyword">jsURL</span>)</span><span class="comment">;</span></span><br><span class="line">JSStringRelease<span class="list">(<span class="keyword">execJSString</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="JS_u7AEF_u8C03_u7528module"><a href="#JS_u7AEF_u8C03_u7528module" class="headerlink" title="JS端调用module"></a>JS端调用module</h2><p>module由上述的JSON配置文件生成后，在JS端可以通过<strong>react-native</strong>对象的<strong>NativeModules</strong>调用。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; NativeModules &#125; = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</span><br><span class="line"><span class="keyword">var</span> &#123; Person &#125; = NativeModules;</span><br><span class="line"></span><br><span class="line">Person.greet(<span class="string">'Tadeu'</span>);</span><br></pre></td></tr></table></figure>
<p>示例代码的运行原理是：JS端发起module方法的调用，进入一个队列，获取调用所需的信息：module名称、方法名称、方法参数，信息获取完成之后交还给JS端执行调用。</p>
<h2 id="u8C03_u7528_u5468_u671F"><a href="#u8C03_u7528_u5468_u671F" class="headerlink" title="调用周期"></a>调用周期</h2><p>使用示例代码调用module时的整个流程如下图所示：</p>
<p><img src="http://tadeuzagallo.com/blog/assets/img/graph.svg" alt="call cycle"></p>
<p>调用始于JS端的本地*JS代码调用，本地JS代码期间：由于调用了<strong>NativeModules</strong>上的方法，调用进入Native端的执行队列。JS端代码发起方法调用结束后，Native端遍历队列中的所有调用并执行对应方法，执行完成后，回JS端回调函数，把处理权转移到JS端，或者通过bridge调用JS端（使用Native端module的<strong>_bridge</strong>引用调用<strong>enqueueJSCall:args:</strong>），把处理权转移到JS端。</p>
<p>*上图只描述了JS执行中的某一个时刻。</p>
<p><strong>注意</strong>：如果你之前曾经关注过项目，可能知道还有一个native–&gt;JS的调用队列，每次vSYNC的时候队列都会被分发，但是为了提高启动速度，这个队列已经被移除了。</p>
<h2 id="u53C2_u6570_u7C7B_u578B"><a href="#u53C2_u6570_u7C7B_u578B" class="headerlink" title="参数类型"></a>参数类型</h2><p>对于从Native端—&gt;JS端的调用，参数类型更容易处理，所有的参数放进<strong>NSArray</strong>，然后被编码成JSON格式。但是对于从JS端—&gt;Native端的调用，为了校验数据类型（int、float、char…），我们需要原生的数据类型。但是对于任意的对象（和结构体），runtime无法通过<strong>NSMethidSignature</strong>提供足够的类型信息。如果你还记得的话，我们已经把参数类型信息作为字符串存下来了。</p>
<p>我们用正则表达式从方法前面里提取出类型信息，然后用<strong><u>RCTConvert</u></strong>功能类转换对象。RCTConvert为所有支持的默认类型提供了转换方法，可以把JSON格式的输入转换成期望的类型。</p>
<p>我们用<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_msgSend" target="_blank" rel="external">objc_msgSend</a></strong>进行RCTConvert方法的动态调用。如果参数类型是<strong>struct</strong>，由于<strong>arm64</strong>没有提供<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_msgSend_stret" target="_blank" rel="external">objc_msgSend_stret</a></strong>的实现，我们用<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/" target="_blank" rel="external">NSInvocation</a></strong>调用。</p>
<p>获取到所有的参数之后，通过<strong>NSInvocation</strong>调用目标的module和方法。</p>
<p>下面是一个栗子：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// If you had the following method in a given module, e.g. <span class="code">`MyModule`</span></span><br><span class="line">RCT<span class="emphasis">_EXPORT_</span>METHOD(methodWithArray:(NSArray *) size:(CGRect)size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// And called it from JS, like:</span><br><span class="line">require('NativeModules').MyModule.method(['a', 1], &#123;</span><br><span class="line">  x: 0,</span><br><span class="line">  y: 0,</span><br><span class="line">  width: 200,</span><br><span class="line">  height: 100</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// The JS queue sent to native would then look like the following:</span><br><span class="line">// <span class="strong">** Remember that it's a queue of calls, so all the fields are arrays **</span></span><br><span class="line">@[</span><br><span class="line">  @[ @0 ], // module IDs</span><br><span class="line">  @[ @1 ], // method IDs</span><br><span class="line">  @[       // arguments</span><br><span class="line"><span class="code">    @[</span></span><br><span class="line"><span class="code">      @[@"a", @1],</span></span><br><span class="line"><span class="code">      @&#123; @"x": @0, @"y": @0, @"width": @200, @"height": @100 &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// This would convert into the following calls (pseudo code)</span><br><span class="line">NSInvocation call</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">0</span>] = GetModuleForId(@0)</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">1</span>] = GetMethodForId(@1)</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">2</span>] = obj_msgSend(RCTConvert, NSArray, @[@"a", @1])</span><br><span class="line">call[<span class="link_label">args</span>][<span class="link_reference">3</span>] = NSInvocation(RCTConvert, CGRect, @&#123; @"x": @0, ... &#125;)</span><br><span class="line">call()</span><br></pre></td></tr></table></figure>
<h2 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h2><p>根据前面提到的， 默认每个module都有各自的<strong><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="external">GCD queue</a></strong>。如果想为module指定运行的queue，需要实现<strong>-methodQueue</strong>方法或者synthesize <strong>methodQueue</strong>属性。继承自<strong><a href="https://github.com/facebook/react-native/blob/master/React/Views/RCTViewManager.m" target="_blank" rel="external">RCTViewManager</a></strong>的<strong>View Managers</strong>*是例外，这些View Managers默认使用<strong>Shadow Queue</strong>，还有一个<strong>RCTJSThread</strong>比较特别，它仅仅是一个占位符，实际上它是指一个<strong>线程</strong>而不是一个<strong>队列</strong>。</p>
<p><strong>*View Managers</strong>实际上也不是例外，它们的基类中显示指定了shadow queue作为目标队列。</p>
<p>目前的线程相关的约定如下：</p>
<ul>
<li><strong>-init</strong>和<strong>-setBridge</strong>的调用在主线程进行；</li>
<li>所有的export的方法调用在指定的队列执行；</li>
<li>如果实现了<strong><a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTInvalidating.h" target="_blank" rel="external">RCTInvalidating</a></strong>协议，<strong>invalidate</strong>的调用在指定的队列执行；</li>
<li><strong>-dealloc</strong>方法在哪个线程调用视情况而定。</li>
</ul>
<p>当Native端收到JS端的批量方法调用时，这些方法调用根据目标队列放入各自组中，并行分发调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// group `calls` by `queue` in `buckets`</span></span><br><span class="line"><span class="keyword">for</span> (id <span class="built_in">queue</span> in buckets) &#123;</span><br><span class="line">  <span class="keyword">dispatch_block_t</span> block = ^&#123;</span><br><span class="line">    NSOrderedSet *calls = [buckets objectForKey:<span class="built_in">queue</span>];</span><br><span class="line">    <span class="keyword">for</span> (NSNumber *indexObj in calls) &#123;</span><br><span class="line">      <span class="comment">// Actually call</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">queue</span> == RCTJSThread) &#123;</span><br><span class="line">    [_javaScriptExecutor executeBlockOnJavaScriptQueue:block];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">queue</span>) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, block);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>上面这些我们大概讲解了一下brigde的工作机制。希望能够对想创建复杂的module或者想要贡献核心代码的同学们提供一些帮助。</p>
<p>如果还有不清晰、不深入的地方，或者想知道一些其他的任何东西，不要犹豫，快来找我吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://tadeuzagallo.com/blog/react-native-bridge/">BRIDGING IN REACT NATIVE</a></p>
<p>本文假定读者了解React Native开发，并且想了解Native和JavaScript通信的内部机制。</p>]]>
    
    </summary>
    
      <category term="React Native" scheme="http://5minsred.com/tags/React-Native/"/>
    
      <category term="iOS" scheme="http://5minsred.com/tags/iOS/"/>
    
      <category term="react-native" scheme="http://5minsred.com/categories/react-native/"/>
    
  </entry>
  
</feed>
